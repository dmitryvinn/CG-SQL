(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{102:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return O}));var a=n(0),i=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),c=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,b=o(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,O=p["".concat(r,".").concat(u)]||p[u]||d[u]||l;return n?i.a.createElement(O,s(s({ref:t},b),{},{components:n})):i.a.createElement(O,s({ref:t},b))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var b=2;b<l;b++)r[b]=n[b];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return c}));var a=n(2),i=n(6),l=(n(0),n(102)),r={id:"ch03",title:"Chapter 3: Expressions, Literals, Nullability, Sensitivity",sidebar_label:"Chapter 3: Expressions, Literals, Nullability, Sensitivity"},s={unversionedId:"ch03",id:"ch03",isDocsHomePage:!1,title:"Chapter 3: Expressions, Literals, Nullability, Sensitivity",description:"\x3c!---",source:"@site/../CQL_Guide/ch03.md",slug:"/ch03",permalink:"/cql-guide/ch03",version:"current",lastUpdatedBy:"Dmitry Vinnik",lastUpdatedAt:1603483613,sidebar_label:"Chapter 3: Expressions, Literals, Nullability, Sensitivity",sidebar:"someSidebar",previous:{title:"Chapter 2: Using Data",permalink:"/cql-guide/ch02"},next:{title:"Chapter 4: Procedures, Functions, and Control Flow",permalink:"/cql-guide/ch04"}},o=[{value:"Expression Examples",id:"expression-examples",children:[]},{value:"Order of Evaluation",id:"order-of-evaluation",children:[]},{value:"Nullability",id:"nullability",children:[]},{value:"Types of Literals",id:"types-of-literals",children:[]},{value:"Nullability Rules",id:"nullability-rules",children:[]},{value:"Expression Types",id:"expression-types",children:[]},{value:"CASE Expressions",id:"case-expressions",children:[]},{value:"Marking Data as Sensitive",id:"marking-data-as-sensitive",children:[]},{value:"Reference Semantics",id:"reference-semantics",children:[]},{value:"Function Return Values",id:"function-return-values",children:[]},{value:"Comparison",id:"comparison",children:[]},{value:"<code>BLOB</code> and <code>OBJECT</code>",id:"blob-and-object",children:[]},{value:"<code>TEXT</code>",id:"text",children:[]},{value:"Sample Code",id:"sample-code",children:[]}],b={rightToc:o};function c(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Until this point we've only discussed simple kinds of expressions and as well as variables and table columns marked with ",Object(l.b)("inlineCode",{parentName:"p"},"NOT NULL")," . These are indeed the easiest types for CQL to work with as they tend to correspond most directly to the types known to C.  However\nSQL provides for many more types of expressions as well as nullable types and these require handling in any language that purports to be like SQL."),Object(l.b)("h3",{id:"expression-examples"},"Expression Examples"),Object(l.b)("p",null,"The usual arithmetic operators apply in CQL:"),Object(l.b)("p",null,"Example expressions (these are all true)"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"(1 + 2) * 3 == 9\n1 + 2 * 3 == 7\n6 / 3 == 2\n7 - 5 == 2\n6 % 5 == 1\n5 / 2.5 == 2\n7 & 3 == 2 | 1\n1 << 2 == 4\n")),Object(l.b)("p",null,"However, before going any further it's important to note that CQL is inherently a two-headed beast.  Expressions are either evaluated by transpiling to C (like the predicate of an IF statement, or a variable assignment) or by sending them to SQLIte for evaluation (like expressions inside a ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," statement or the ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," part of a ",Object(l.b)("inlineCode",{parentName:"p"},"DELETE"),")."),Object(l.b)("p",null,"CQL evaluation rules are designed to be as similar as possible but some variance is inevitable because evaluation is done in two fundamentally different way."),Object(l.b)("h3",{id:"order-of-evaluation"},"Order of Evaluation"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"ASSIGNMENT:    :=\nLOGICAL_OR:    OR\nLOGICAL_AND:   AND\nEQUALITY:      = == != <> IS, IS NOT, IN, NOT IN, LIKE, GLOB, MATCH, REGEXP\nINEQUALITY:    <   <=  >   >=\nLOGICAL_NOT:   NOT\nBINARY:        << >> & |\nBETWEEN:       BETWEEN  NOT BETWEEN\nADDITION:      + -\nMULIPLICATION: * / %\nBINARY_NOT:    ~\nCONCAT:        ||\n")),Object(l.b)("p",null,"NOTE: the above is NOT the C binding order (!!!)  The Sqlite binding order is used in the language and parens are added in the C output as needed to force that order.   CQL's rewriting emits minimal parens in all outputs.  Different parens are often needed for SQL output."),Object(l.b)("h3",{id:"nullability"},"Nullability"),Object(l.b)("p",null,"Just as in SQL the absence of ",Object(l.b)("inlineCode",{parentName:"p"},"NOT NULL")," implies that ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," is a legal value. Consider this example:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"create table mixed_nulls(\n  i1 integer,\n  b1 bool,\n  l1 long,\n  r1 real,\n  t1 text,\n  bl1 blob\n);\n\ndeclare i2 integer;\ndeclare b2 bool;\ndeclare l2 long;\ndeclare r2 real;\ndeclare t2 text;\ndeclare bl2 blob;\n")),Object(l.b)("p",null,"ALL of ",Object(l.b)("inlineCode",{parentName:"p"},"i1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"i2"),", ",Object(l.b)("inlineCode",{parentName:"p"},"b1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"b2"),", ",Object(l.b)("inlineCode",{parentName:"p"},"l1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"l2"),", ",Object(l.b)("inlineCode",{parentName:"p"},"r1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"r2"),", ",Object(l.b)("inlineCode",{parentName:"p"},"t1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"t2"),", and ",Object(l.b)("inlineCode",{parentName:"p"},"bl1"),", ",Object(l.b)("inlineCode",{parentName:"p"},"bl2")," are nullable. In some sense variables and columns declared nullable\n(by virtual of the missing ",Object(l.b)("inlineCode",{parentName:"p"},"NOT NULL"),") are the root sources of nullability in the SQL language.  That and the ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," literal.  Though there are other sources\nas we will see."),Object(l.b)("p",null,"In the context of computing the types of expressions, CQL is statically typed and so it must make a decision about the type of any expression based on the type information at hand at compile time.  As a result it handles the static type of an expression conservatively.  If the result might be null then the expression is of a nullable type and the compiled code will include an affordance for the possibility of a null value at runtime."),Object(l.b)("p",null,"The generated code for nullable types is considerably less efficient and so it should be avoided if that is reasonably possible."),Object(l.b)("h3",{id:"types-of-literals"},"Types of Literals"),Object(l.b)("p",null,"There are a number of literal objects that may be expressed in CQL.  These are as follows:"),Object(l.b)("h4",{id:"string-literals"},"String Literals"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"A double quoted string is a C style string literal",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the usual simple C escape sequences are supported, however"),Object(l.b)("li",{parentName:"ul"},"the \\xNN form is not supported, nor is the \\0NNN octal form supported",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"these are actually invaluable and likely to be supported in the near future"))))),Object(l.b)("li",{parentName:"ul"},"a single quoted string is a SQL style string literal",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"No escape sequences are supported other than ",Object(l.b)("inlineCode",{parentName:"li"},"''")," to indicate a single quote character"))),Object(l.b)("li",{parentName:"ul"},'The sequence @FILE("some_string") is a special string literal',Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the value of this literal is the path of the current compiland starting at the letters in ",Object(l.b)("inlineCode",{parentName:"li"},"some_string"),", or"),Object(l.b)("li",{parentName:"ul"},"the entire path of the current compiland if ",Object(l.b)("inlineCode",{parentName:"li"},"some_string")," does not occur in the path"),Object(l.b)("li",{parentName:"ul"},"the purpose of the ",Object(l.b)("inlineCode",{parentName:"li"},"@FILE")," construct is to provide a partial path to a file for diagnostics that is consistent even if the file is built in various different root paths on different build machines")))),Object(l.b)("h4",{id:"blob-literals"},"Blob Literals"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"SQLite Blob literals are supported in SQL contexts (i.e. where they will be processed by SQLite), CQL produces an error if you attempt to use a blob literal in a loose expression")),Object(l.b)("h4",{id:"numeric-literals"},"Numeric Literals"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"All numeric literals are considered to be positive; negative numbers are actually a positive literal combined with unary minus (the negation operator)"),Object(l.b)("li",{parentName:"ul"},"Only base 10 literals are supported"),Object(l.b)("li",{parentName:"ul"},"Literals with a decimal point are of type ",Object(l.b)("inlineCode",{parentName:"li"},"REAL")," and stored as the C type ",Object(l.b)("inlineCode",{parentName:"li"},"double")),Object(l.b)("li",{parentName:"ul"},"Literals that can fit in a signed integer without loss, and do not end in the letter ",Object(l.b)("inlineCode",{parentName:"li"},"L")," are integer literals"),Object(l.b)("li",{parentName:"ul"},"Larger literals, or those ending with the letter ",Object(l.b)("inlineCode",{parentName:"li"},"L")," are long integer literals.")),Object(l.b)("p",null,"Examples:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"  1.3            -- real\n  2L             -- long\n  123456789123   -- long\n  123            -- integer\n")),Object(l.b)("h4",{id:"the-null-literal"},"The NULL literal"),Object(l.b)("p",null,"The use of ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," always gives a nullable result however this literal is special in that it has no storage class. ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," is not numeric, or string but rather mutates into\nwhatever it is first combined with.   For instance ",Object(l.b)("inlineCode",{parentName:"p"},"NULL + 1")," results in a nullable integer.  Because ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," has no primitive type in some cases where type knowledge\nis required you might have to use the CAST() function to cast the NULL to a specific type such as ",Object(l.b)("inlineCode",{parentName:"p"},"CAST(NULL as TEXT)"),".   This construct guarantees type consistence in cases like ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," from different sources combined with ",Object(l.b)("inlineCode",{parentName:"p"},"UNION ALL")),Object(l.b)("p",null,"Note:  constructs like ",Object(l.b)("inlineCode",{parentName:"p"},"CAST(NULL as TEXT)")," are always rewritten to just ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," before going to SQLite as the cast is uninteresting except for the type information which SQLite doesn't need/use anyway."),Object(l.b)("h4",{id:"other-considerations"},"Other Considerations"),Object(l.b)("p",null,"There are no boolean literals other than the integers ",Object(l.b)("inlineCode",{parentName:"p"},"0")," and ",Object(l.b)("inlineCode",{parentName:"p"},"1"),"."),Object(l.b)("p",null,"The C pre-processor is often combined with CQL in which case the ",Object(l.b)("inlineCode",{parentName:"p"},"_FILE_")," and ",Object(l.b)("inlineCode",{parentName:"p"},"_LINE_")," directives may be used to create literals; they will be preprocessed into normal literals."),Object(l.b)("p",null,"The use of ",Object(l.b)("inlineCode",{parentName:"p"},"_FILE_")," can give surprising results in the presence of build systems, hence the existence of ",Object(l.b)("inlineCode",{parentName:"p"},"@FILE(...)"),"."),Object(l.b)("h3",{id:"nullability-rules"},"Nullability Rules"),Object(l.b)("h4",{id:"general-rule"},"General Rule"),Object(l.b)("p",null,"Except as noted in the exceptions below, the result of an operator is nullable if and only if any of its operands\nare nullable. This applies no matter the number of operands the operator requires."),Object(l.b)("p",null,"Note: CQL does not do constant folding or other inferencing, it only uses the types of the values"),Object(l.b)("h4",{id:"identifiers-and-literals"},"Identifiers and Literals"),Object(l.b)("p",null,"Nullable variables and columns are always nullable.  The ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," literal is nullable.  Other literals are not nullable."),Object(l.b)("h4",{id:"is-and-is-not"},"IS and IS NOT"),Object(l.b)("p",null,"These operators always return a non-null boolean."),Object(l.b)("h4",{id:"in-and-not-in"},"IN and NOT IN"),Object(l.b)("p",null,"In an expression like ",Object(l.b)("inlineCode",{parentName:"p"},"needle IN (haystack)")," the result is always a boolean. The boolean is nullable if and only if ",Object(l.b)("inlineCode",{parentName:"p"},"needle")," is nullable. The presence of nulls in the the haystack is irrelevant."),Object(l.b)("p",null,"NOTE: SQLite has slightly different nullability rules for ",Object(l.b)("inlineCode",{parentName:"p"},"IN")," and ",Object(l.b)("inlineCode",{parentName:"p"},"NOT IN")," q.v."),Object(l.b)("h4",{id:"case-when-then-else-end"},"CASE ..WHEN ..THEN.. ELSE.. END"),Object(l.b)("p",null,"The following rules apply when considering nullability of a ",Object(l.b)("inlineCode",{parentName:"p"},"CASE")," expression."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"if there is no ",Object(l.b)("inlineCode",{parentName:"li"},"ELSE")," clause, the result is nullable."),Object(l.b)("li",{parentName:"ul"},"if any of the output values (i.e. any ",Object(l.b)("inlineCode",{parentName:"li"},"THEN")," or ",Object(l.b)("inlineCode",{parentName:"li"},"ELSE")," values) are nullable, the result is nullable"),Object(l.b)("li",{parentName:"ul"},"otherwise the result is not nullable")),Object(l.b)("p",null,"The SQL ",Object(l.b)("inlineCode",{parentName:"p"},"CASE")," construct is quite powerful and unlike the C ",Object(l.b)("inlineCode",{parentName:"p"},"switch")," statement it is actually an expression.  So it's rather more like a highly generalized ternary ",Object(l.b)("inlineCode",{parentName:"p"},"a ? b : c")," operator rather than the switch statement.   There can be\narbitrarily many conditions specified each with their own result and the conditions need not be constants and\ntypically are not."),Object(l.b)("h4",{id:"the-ifnull-and-coalesce-functions"},"The IFNULL and COALESCE Functions"),Object(l.b)("p",null,"These functions are nullable or non-nullable based on their arguments. If the ",Object(l.b)("inlineCode",{parentName:"p"},"IFNULL")," or ",Object(l.b)("inlineCode",{parentName:"p"},"COALESCE")," call has\nat least one non-nullable argument then the result is non-nullable."),Object(l.b)("h4",{id:"left-and-right-outer-joins"},"LEFT and RIGHT OUTER JOINS"),Object(l.b)("p",null,"In most join operations the nullability of each column participating in the join is preserved.  However in a\n",Object(l.b)("inlineCode",{parentName:"p"},"LEFT OUTER")," join the columns on the right side of the join are always considered nullable and in a\n",Object(l.b)("inlineCode",{parentName:"p"},"RIGHT OUTER")," join the columns on the left side of the join are considered nullable."),Object(l.b)("p",null,"NOTE: CQL does not use constraints in the ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE"),", ",Object(l.b)("inlineCode",{parentName:"p"},"ON"),", or ",Object(l.b)("inlineCode",{parentName:"p"},"HAVING")," clause to infer non-null status even where this would be possible.  CQL does no data-flow at all."),Object(l.b)("h3",{id:"expression-types"},"Expression Types"),Object(l.b)("p",null,"CQL supports a variety of expressions, nearly everything from the SQLite world.  The following are the various supported operators, they are presented in order from the weakest binding strength to the strongest.\nNote that the binding order is NOT the same as C, in some cases it is radically different (e.g. boolean math)"),Object(l.b)("h4",{id:"union-and-union-all"},"UNION and UNION ALL"),Object(l.b)("p",null,"These appear only in the context of ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," statements.  The arms of a compound select may include ",Object(l.b)("inlineCode",{parentName:"p"},"FROM"),", ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE"),", ",Object(l.b)("inlineCode",{parentName:"p"},"GROUP BY"),", ",Object(l.b)("inlineCode",{parentName:"p"},"HAVING"),", and ",Object(l.b)("inlineCode",{parentName:"p"},"WINDOW"),".  If ",Object(l.b)("inlineCode",{parentName:"p"},"ORDER BY")," or ",Object(l.b)("inlineCode",{parentName:"p"},"LIMIT ... OFFSET")," are present, these apply to the entire UNION."),Object(l.b)("p",null,"example:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"select A.x x from A inner join B using(z)\nunion all\nselect C.x x from C\nwhere x = 1;\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," applies only to the second select in the union.  And each ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," is evaluated before the the ",Object(l.b)("inlineCode",{parentName:"p"},"UNION ALL")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"select A.x x from A inner join B using(z)\nwhere x = 3\nunion all\nselect C.x x from C\nwhere x = 1\norder by x;\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"ORDER BY")," applies to the result of the union, so any results from the 2nd branch will sort before any results from the first branch (because ",Object(l.b)("inlineCode",{parentName:"p"},"x")," is constrained in both)."),Object(l.b)("h4",{id:"assignment"},"Assignment"),Object(l.b)("p",null,"Assignment only occurs in the ",Object(l.b)("inlineCode",{parentName:"p"},"UPDATE")," statement or in the ",Object(l.b)("inlineCode",{parentName:"p"},"SET")," statement.  In both cases the left side\nis a simple target and the right side is a general expression.  The expression is evaluated before the assignment."),Object(l.b)("p",null,"example:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"SET x := 1 + 3 AND 4;  -- + before AND then :=\n")),Object(l.b)("h4",{id:"logical-or"},"Logical OR"),Object(l.b)("p",null,"The logical ",Object(l.b)("inlineCode",{parentName:"p"},"OR")," operator does shortcut evaluation, much like the C ",Object(l.b)("inlineCode",{parentName:"p"},"||")," operator (not to be confused with SQL's concatenation operator with the same lexeme)."),Object(l.b)("p",null,"The truth table for logical ",Object(l.b)("inlineCode",{parentName:"p"},"OR")," is as follows:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"A"),Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"B"),Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"A OR B"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")))),Object(l.b)("h4",{id:"logical-and"},"Logical AND"),Object(l.b)("p",null,"The logical ",Object(l.b)("inlineCode",{parentName:"p"},"AND")," operator does shortcut evaluation, much like the C ",Object(l.b)("inlineCode",{parentName:"p"},"&&")," operator, so if the left side is zero the result is 0 and the right side is not evaluated."),Object(l.b)("p",null,"The truth table for logical ",Object(l.b)("inlineCode",{parentName:"p"},"AND")," is as follows:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"A"),Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"B"),Object(l.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"A AND B"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"0")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"1"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL"),Object(l.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"NULL")))),Object(l.b)("h4",{id:"between-and-not-between"},"BETWEEN and NOT BETWEEN"),Object(l.b)("p",null,"These are a ternary type operation.  The general forms are:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"  expr1 BETWEEN expr2 AND expr3\n  expr1 NOT BETWEEN expr2 AND expr3\n")),Object(l.b)("p",null,"Note that there is an inherent ambiguity in the language because ",Object(l.b)("inlineCode",{parentName:"p"},"expr2")," or ",Object(l.b)("inlineCode",{parentName:"p"},"expr3")," could be logical expressions that include ",Object(l.b)("inlineCode",{parentName:"p"},"AND"),". CQL resolves this ambiguity by insisting that ",Object(l.b)("inlineCode",{parentName:"p"},"expr2")," and ",Object(l.b)("inlineCode",{parentName:"p"},"expr3"),' be "math expressions" in the grammar.'),Object(l.b)("p",null,'"Math expressions" consist of:'),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"bitwise ",Object(l.b)("inlineCode",{parentName:"li"},"&")," and ",Object(l.b)("inlineCode",{parentName:"li"},"|")),Object(l.b)("li",{parentName:"ul"},"bitwise left shift or right shift (",Object(l.b)("inlineCode",{parentName:"li"},"<<")," and ",Object(l.b)("inlineCode",{parentName:"li"},">>"),")"),Object(l.b)("li",{parentName:"ul"},"addition (",Object(l.b)("inlineCode",{parentName:"li"},"+"),")"),Object(l.b)("li",{parentName:"ul"},"subtraction (",Object(l.b)("inlineCode",{parentName:"li"},"-"),")"),Object(l.b)("li",{parentName:"ul"},"multiplication (",Object(l.b)("inlineCode",{parentName:"li"},"*"),")"),Object(l.b)("li",{parentName:"ul"},"division (",Object(l.b)("inlineCode",{parentName:"li"},"/"),")"),Object(l.b)("li",{parentName:"ul"},"modulus (",Object(l.b)("inlineCode",{parentName:"li"},"%"),")"),Object(l.b)("li",{parentName:"ul"},"unary negation (",Object(l.b)("inlineCode",{parentName:"li"},"-"),")"),Object(l.b)("li",{parentName:"ul"},"literals"),Object(l.b)("li",{parentName:"ul"},"any parenthesized expression")),Object(l.b)("p",null,"Hence:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- oh hell no (syntax error)\na between 1 and 2 and 3;\n\n-- all ok\na between (1 and 2) and 3;\na between 1 and (2 and 3);\na between 1 + 2 and 12 / 2;\n")),Object(l.b)("p",null,"These considerations force the grammar to contain special rules for expressions after ",Object(l.b)("inlineCode",{parentName:"p"},"BETWEEN"),"."),Object(l.b)("h4",{id:"logical-not"},"Logical NOT"),Object(l.b)("p",null,"The one operand of logical not must be a numeric.  ",Object(l.b)("inlineCode",{parentName:"p"},"NOT 'x'")," is illegal."),Object(l.b)("h4",{id:"non-ordering-tests-----like-glob-match-in-not-in-is-is-not"},"Non-ordering tests ",Object(l.b)("inlineCode",{parentName:"h4"},"!="),", ",Object(l.b)("inlineCode",{parentName:"h4"},"<>"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"="),", ",Object(l.b)("inlineCode",{parentName:"h4"},"=="),", ",Object(l.b)("inlineCode",{parentName:"h4"},"LIKE"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"GLOB"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"MATCH"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"IN"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"NOT IN"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"IS"),", ",Object(l.b)("inlineCode",{parentName:"h4"},"IS NOT")),Object(l.b)("p",null,"These operations do some non-ordered comparison of their two operands."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"IS")," and ",Object(l.b)("inlineCode",{parentName:"li"},"IS NOT")," never return ",Object(l.b)("inlineCode",{parentName:"li"},"NULL"),",  So for instance ",Object(l.b)("inlineCode",{parentName:"li"},"X IS NOT NULL")," gives the natural answer.  ",Object(l.b)("inlineCode",{parentName:"li"},"x IS y")," is true if and only if: 1. both ",Object(l.b)("inlineCode",{parentName:"li"},"x")," and ",Object(l.b)("inlineCode",{parentName:"li"},"y")," are ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," or 2. if they are equal."),Object(l.b)("li",{parentName:"ul"},"The other operators return ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," if either operand is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," and otherwise perform their usual test to produce a boolean"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"!=")," and ",Object(l.b)("inlineCode",{parentName:"li"},"<>")," are equivalent as are ",Object(l.b)("inlineCode",{parentName:"li"},"=")," and ",Object(l.b)("inlineCode",{parentName:"li"},"==")),Object(l.b)("li",{parentName:"ul"},"strings and blobs compare equal based on their value, not their identity (i.e. not the string/blob pointer)"),Object(l.b)("li",{parentName:"ul"},"objects compare equal based on their address, not their content (i.e. reference equality)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"MATCH")," and ",Object(l.b)("inlineCode",{parentName:"li"},"GLOB")," only valid in SQL contexts, ",Object(l.b)("inlineCode",{parentName:"li"},"LIKE")," can be used in any context (a helper method to do ",Object(l.b)("inlineCode",{parentName:"li"},"LIKE")," in C is provided by SQLite, but not the others)")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"})," NULL IS NULL  -- this is true\n(NULL == NULL) IS NULL  -- this is also true because NULL == NULL is not 1, it's NULL.\n(NULL != NULL) IS NULL  -- this is also true because NULL != NULL is not 0, it's also NULL.\n")),Object(l.b)("h4",{id:"ordering-comparisons----"},"Ordering comparisons <, >, <=, >="),Object(l.b)("p",null,"These operators do the usual order comparison of their two operands."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"If either operand is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," the result is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")),Object(l.b)("li",{parentName:"ul"},"Objects and Blobs may not be compared with these operands"),Object(l.b)("li",{parentName:"ul"},"Strings are compared based on their value (as with other comparisons) not their address"),Object(l.b)("li",{parentName:"ul"},"Numerics are compared as usual with the usual promotion rules")),Object(l.b)("p",null,"NOTE: CQL uses ",Object(l.b)("inlineCode",{parentName:"p"},"strcmp")," for string comparison. In SQL expressions the comparison happens in whatever way SQLite has been configured. Typically general purpose string comparison should be done with helper functions that deal with collation and other considerations.  This is a very complex topic and CQL is largely silent on it."),Object(l.b)("h4",{id:"bitwise-operators----"},"Bitwise operators <<, >>, &, |"),Object(l.b)("p",null,"These are the bit-manipulation operations.  Their binding strength is VERY different than C so beware.\nAnd notably the ",Object(l.b)("inlineCode",{parentName:"p"},"&")," operator has the same binding strength as the ",Object(l.b)("inlineCode",{parentName:"p"},"|"),' operator so they bind left to right,\nthis is utterly unlike most systems.  Many parenthesis are likely to be needed to get the usual "or of ands" patterns codified correctly.  Likewise the shift operators ',Object(l.b)("inlineCode",{parentName:"p"},"<<")," and ",Object(l.b)("inlineCode",{parentName:"p"},">>")," are the same strength as ",Object(l.b)("inlineCode",{parentName:"p"},"&")," and ",Object(l.b)("inlineCode",{parentName:"p"},"|")," which is very atypical. Consider:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"x & 1 << 7;    -- probably doesn't mean what you think (this is not ambigous, it's well defined, but unlike C)\n(x & 1) << 7;   -- means the same as the above\nx & (1 << 7)   -- probably what you intended\n")),Object(l.b)("p",null,"Note that these operators only work on integer and long integer data.  If any operand is ",Object(l.b)("inlineCode",{parentName:"p"},"NULL")," the result is `NULL."),Object(l.b)("h4",{id:"addition-and-subtraction---"},"Addition and Subtraction +, -"),Object(l.b)("p",null,"These operators do the typical math.  Note that there are no unsigned numerics so it's always signed math that is happening here."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},'operands are promoted to the "biggest" type involved as previously described (bool -> int -> long -> real)'),Object(l.b)("li",{parentName:"ul"},"only numeric operands are legal (no adding strings)"),Object(l.b)("li",{parentName:"ul"},"if any operand is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," the result is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL"))),Object(l.b)("h4",{id:"multiplication-division-modulus---"},"Multiplication, Division, Modulus *, /, %"),Object(l.b)("p",null,"These operators do the typical math.  Note that there are no unsigned numerics so it's always signed math that is happening here."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},'operands are promoted to the "biggest" type as previously described (bool -> int -> long -> real)'),Object(l.b)("li",{parentName:"ul"},"only numeric operands are legal (no multiplying strings)"),Object(l.b)("li",{parentName:"ul"},"if any operand is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," the result is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL"))),Object(l.b)("p",null,"EXCEPTION: the ",Object(l.b)("inlineCode",{parentName:"p"},"%")," operator doesn't make sense on real values, so real values produces an error."),Object(l.b)("h4",{id:"unary-operators---"},"Unary operators -, ~"),Object(l.b)("p",null,"Unary negation (",Object(l.b)("inlineCode",{parentName:"p"},"-"),") and bitwise invert (",Object(l.b)("inlineCode",{parentName:"p"},"~"),") are the strongest binding operators."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The ",Object(l.b)("inlineCode",{parentName:"li"},"~")," operator only works on integer types (not text, not real)"),Object(l.b)("li",{parentName:"ul"},"the usual promotion rules otherwise apply"),Object(l.b)("li",{parentName:"ul"},"if the operand is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," the result is ",Object(l.b)("inlineCode",{parentName:"li"},"NULL"))),Object(l.b)("h3",{id:"case-expressions"},"CASE Expressions"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"case")," expression has two major forms and provides a great deal of flexibility in an expression.  You can kind of think of it as the C ",Object(l.b)("inlineCode",{parentName:"p"},"?:")," operator on steroids."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"set x := 'y';\nselect case x\n  when 'y' then 1\n  when 'z' then 2\n  else 3\nend;\n")),Object(l.b)("p",null,"In this form the expression in the case ",Object(l.b)("inlineCode",{parentName:"p"},"x")," here is evaluated exactly once and then compared against each ",Object(l.b)("inlineCode",{parentName:"p"},"when")," clause, they must be type compatible with the expression.  The ",Object(l.b)("inlineCode",{parentName:"p"},"then")," expression that corresponds is evaluated and becomes the result, or the ",Object(l.b)("inlineCode",{parentName:"p"},"else")," expression if present and no ",Object(l.b)("inlineCode",{parentName:"p"},"when")," matches.  If there is no else and no match the result is ",Object(l.b)("inlineCode",{parentName:"p"},"null"),"."),Object(l.b)("p",null,"If that's not general enough, there is an alternate form:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"set y := 'yy';\nset z := 'z';\nselect case\n  when y = 'y' then 1\n  when z = 'z' then 2\n  else 3\nend;\n")),Object(l.b)("p",null,"The second form, where there is no value before the first ",Object(l.b)("inlineCode",{parentName:"p"},"when")," keyword, each ",Object(l.b)("inlineCode",{parentName:"p"},"when")," expression is a separate independent boolean expression.  The first one that evaluates to true causes the corresponding ",Object(l.b)("inlineCode",{parentName:"p"},"then")," to be evaluated and that becomes the result.  If there are no matches the result is the ",Object(l.b)("inlineCode",{parentName:"p"},"else")," expression, or ",Object(l.b)("inlineCode",{parentName:"p"},"null")," if there is no ",Object(l.b)("inlineCode",{parentName:"p"},"else"),"."),Object(l.b)("p",null,"The result types must be compatible and the best type to hold the answer is selected with the usual promotion rules."),Object(l.b)("h3",{id:"marking-data-as-sensitive"},"Marking Data as Sensitive"),Object(l.b)("p",null,"CQL supports the notion of 'sensitive' data in a first class way.  You can think of it as very much like nullability;  It largely begins by tagging data columns with ",Object(l.b)("inlineCode",{parentName:"p"},"@sensitive")),Object(l.b)("p",null,"Rather than go through the whole calculus, it's easier to understand by a series of examples.  So let's start with a table with some sensitive data."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"create table with_sensitive(\n id integer,\n name text @sensitive,\n sens integer @sensitive\n);\n")),Object(l.b)("p",null,"The most obvious thing you might do at this point is create a stored proc that would read data out of that table.  Maybe something like this:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"create proc get_sensitive()\nbegin\n  select id as not_sensitive_1,\n        sens + 1 sensitive_1,\n        name as sensitive_2,\n        'x' as not_sensitive_2,\n        -sens as sensitive_3,\n        sens between 1 and 3 as sensitive_4\n  from with_sensitive;\nend;\n")),Object(l.b)("p",null,"So looking at that procedure we can see that it's reading sensitive data, the result will have some sensitive columns in it."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},'the "id" is not sensitive (at least not in this example)'),Object(l.b)("li",{parentName:"ul"},"sens + 1 is sensitive, math on a sensitive field leaves it sensitive"),Object(l.b)("li",{parentName:"ul"},"name is sensitive, it began that way and is unchanged"),Object(l.b)("li",{parentName:"ul"},"'x' is just a string literal, it's not sensitive"),Object(l.b)("li",{parentName:"ul"},"-sens is sensitive, that's more math"),Object(l.b)("li",{parentName:"ul"},"and the between expression is also sensitive")),Object(l.b)("p",null,'Generally sensitivity is "radioactive" anything it touches becomes sensitive.  This is very important because even a simple looking boolean expression like ',Object(l.b)("inlineCode",{parentName:"p"},"is_gay IS NOT NULL")," must lead to a sensitive result or the whole process would be largely useless.  It has to be basically impossible to wash away sensitivity."),Object(l.b)("p",null,"These rules apply to normal expressions as well as expressions in the context of SQL.  Accordingly:"),Object(l.b)("p",null,"Sensitive variables can be declared:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"declare sens integer @sensitive;\n")),Object(l.b)("p",null,"Simple operations on the variables are sensitive"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- this is sensitive (and the same would be true for any other math)\nsens + 1;\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"IN")," expression gives you sensitive results if anything about it is sensitive"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- all of these are sensitive\nsens in (1, 2);\n1 in (1, sens);\n(select id in (select sens from with_sensitive));\n")),Object(l.b)("p",null,"Similarly sensitive constructs in ",Object(l.b)("inlineCode",{parentName:"p"},"CASE")," expressions result in a sensitive output"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- not sensitive\ncase 0 when 1 then 2 else 3 end;\n\n-- all of these are sensitive\ncase sens when 1 then 2 else 3 end;\ncase 0 when sens then 2 else 3 end;\ncase 0 when 1 then sens else 3 end;\ncase 0 when 1 then 2 else sens end;\n")),Object(l.b)("p",null,"Cast operations preserve sensitivity"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- sensitive result\nselect cast(sens as INT);\n")),Object(l.b)("p",null,"Aggregate functions likewise preserve sensitivity"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- all of these are sensitive\nselect AVG(T1.sens) from with_sensitive T1;\nselect MIN(T1.sens) from with_sensitive T1;\nselect MAX(T1.sens) from with_sensitive T1;\nselect SUM(T1.sens) from with_sensitive T1;\nselect COUNT(T1.sens) from with_sensitive T1;\n")),Object(l.b)("p",null,"There are many operators that get similar treatment such as ",Object(l.b)("inlineCode",{parentName:"p"},"COALESCE"),", ",Object(l.b)("inlineCode",{parentName:"p"},"IFNULL"),", ",Object(l.b)("inlineCode",{parentName:"p"},"IS")," and ",Object(l.b)("inlineCode",{parentName:"p"},"IS NOT"),"."),Object(l.b)("p",null,"Things get more interesting when we come to the ",Object(l.b)("inlineCode",{parentName:"p"},"EXISTS")," operator:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),'-- sensitive if and only if any selected column is sensitive\nexists(select * from with_sensitive)\n\n-- sensitive because "info" is sensitive\nexists(select info from with_sensitive)\n\n-- not sensitive because "id" is not sensitive\nexists(select id from with_sensitive)\n')),Object(l.b)("p",null,"If this is making you nervous, it probably should, we need a little more protection because of the way EXISTS is typically used.  The predicates matter, consider the following:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- id is now sensitive because the predicate of the where clause was sensitive\nselect id from with_sensitive where sens = 1;\n\n-- this expression is now sensitive because id is sensitive in this context\nexists(select id from with_sensitive where sens = 1)\n")),Object(l.b)("p",null,"In general: if the predicate of a ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," or ",Object(l.b)("inlineCode",{parentName:"p"},"HAVING")," clause is sensitive then all columns in the result become sensitive."),Object(l.b)("p",null,"Similarly when performing joins, if the column specified in the ",Object(l.b)("inlineCode",{parentName:"p"},"USING")," clause is sensitive or the predicate of the ",Object(l.b)("inlineCode",{parentName:"p"},"ON")," clause is sensitive then the result of the join is considered to be all sensitive columns (even if the columns were not sensitive in the schema)."),Object(l.b)("p",null,"Likewise a sensitive expression in ",Object(l.b)("inlineCode",{parentName:"p"},"LIMIT")," or ",Object(l.b)("inlineCode",{parentName:"p"},"OFFSET")," will result in 100% sensitive columns as these can be used in a ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE"),"-ish way.  There is no reasonble defense against using ",Object(l.b)("inlineCode",{parentName:"p"},"LIMIT")," and testing for the presence or absence of a row as a way to wash away sensitivity so that is a weakness, but the rules that are present are likely to be very helpful."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql"}),"-- join with ON\nselect T1.id from with_sensitive T1 inner join with_sensitive T2 on T1.sens = T2.sens\n\n-- join with USING\nselect T1.id from with_sensitive T1 inner join with_sensitive T2 using(sens);\n")),Object(l.b)("p",null,"All of these expression and join propagations are designed to make it impossible to simply wash-away sensitivity with a little bit of math."),Object(l.b)("p",null,'Now we come to enforcement, which boils down to what assignments or "assignment-like" operations we allow.'),Object(l.b)("p",null,"If we have these:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"declare sens integer @sensitive;\ndeclare not_sens integer;\n")),Object(l.b)("p",null,"We can use those as stand-ins for lots of expressions, but the essential calculus goes like this:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"-- assigning a sensitive to a sensitive is ok\nset sens := sens + 1;\n\n-- assigning not sensitive data to a sensitive is ok\n-- this is needed so you can (e.g.) initialize to zero\nset sens := not_sens;\n\n-- not ok\nset not_sens := sens;\n")),Object(l.b)("p",null,'Now these "assignments" can happen in a variety of ways:'),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"you can set an out parameter of your procedure"),Object(l.b)("li",{parentName:"ul"},"when calling a function or procedure, we require:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'any IN parameters of the target be "assignable" from the value of the argument expression'),Object(l.b)("li",{parentName:"ul"},'any OUT parameters of the target be "assignable" from the procedures type to the argument variable'),Object(l.b)("li",{parentName:"ul"},"any IN/OUT parameters require both the above")))),Object(l.b)("p",null,"Now it's possible to write a procedure that accepts sensitive things and returns non-sensitive things.  This is fundamentally necessary because the proc must be able return (e.g.) a success code, or encrypted data, that is not sensitive.  However, if you write the procedure in CQL it, too, will have to follow the assignment rules and so cheating will be quite hard.  The idea here is to make it easy to do handle sensitive data well and make typical mistakes trigger errors."),Object(l.b)("p",null,"With these rules  it's possible to compute the the type of procedure result sets and also to enforce IN/OUT parameters.  Since the signature of procedures is conveniently generated with --generate_exports good practices are fairly easy to follow and sensitivity checks flow well into your programs."),Object(l.b)("p",null,"This is a brief summary of CQL semantics for reference types -- those types that are ref counted by the runtime."),Object(l.b)("p",null,"The three reference types are:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"TEXT"),Object(l.b)("li",{parentName:"ul"},"OBJECT"),Object(l.b)("li",{parentName:"ul"},"BLOB")),Object(l.b)("p",null,"Each of these has their own macro for ",Object(l.b)("inlineCode",{parentName:"p"},"retain")," and ",Object(l.b)("inlineCode",{parentName:"p"},"release")," though all three actually turn into the exact same code in all the cu rrent CQL runtime implementations.  In all cases the object is expected to be promptly freed when the reference count falls to zero."),Object(l.b)("h3",{id:"reference-semantics"},"Reference Semantics"),Object(l.b)("h4",{id:"stored-procedure-arguments"},"Stored Procedure Arguments"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"in")," and ",Object(l.b)("inlineCode",{parentName:"li"},"inout")," arguments are not retained on entry to a stored proc"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"out")," arguments are assumed to contain garbage and are nulled without retaining on entry"),Object(l.b)("li",{parentName:"ul"},"if your ",Object(l.b)("inlineCode",{parentName:"li"},"out")," argument doesn't have garbage in it, then it is up to you do ",Object(l.b)("inlineCode",{parentName:"li"},"release")," it before you make a call"),Object(l.b)("li",{parentName:"ul"},"When calling a proc with an ",Object(l.b)("inlineCode",{parentName:"li"},"out")," argument CQL will ",Object(l.b)("inlineCode",{parentName:"li"},"release")," the argument variable before the call site, obeying its own contract")),Object(l.b)("h4",{id:"local-variables"},"Local Variables"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"assigning to a local variable ",Object(l.b)("inlineCode",{parentName:"li"},"retains")," the object, and then does a ",Object(l.b)("inlineCode",{parentName:"li"},"release")," on the previous object"),Object(l.b)("li",{parentName:"ul"},"this order is important, all assignments are done in this way in case of aliasing (",Object(l.b)("inlineCode",{parentName:"li"},"release")," first might accidentally free too soon)"),Object(l.b)("li",{parentName:"ul"},"CQL calls ",Object(l.b)("inlineCode",{parentName:"li"},"release")," on all local variable when the method exits")),Object(l.b)("h4",{id:"assigning-to-an-out-parameter-or-a-global-variable"},"Assigning to an ",Object(l.b)("inlineCode",{parentName:"h4"},"out")," parameter or a global variable"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"out,"),"inout",Object(l.b)("inlineCode",{parentName:"li"},"parameters, and global variables work just like local variables except that CQL does not call"),"release` at the end of the procedure")),Object(l.b)("h3",{id:"function-return-values"},"Function Return Values"),Object(l.b)("p",null,"Stored procedures do not return values, they only have ",Object(l.b)("inlineCode",{parentName:"p"},"out")," arguments and those are well defined as above.  Functions however are also supported and they can have either ",Object(l.b)("inlineCode",{parentName:"p"},"get")," or ",Object(l.b)("inlineCode",{parentName:"p"},"create")," semantics"),Object(l.b)("h4",{id:"get-semantics"},"Get Semantics"),Object(l.b)("p",null,"If you declare a function like so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"declare function Getter() object;\n")),Object(l.b)("p",null,"Then CQL assumes that the returned object should follow the normal rules above, retain/release will balance by the end of the procedure for locals and globals or ",Object(l.b)("inlineCode",{parentName:"p"},"out")," arguments could retain the object."),Object(l.b)("h4",{id:"create-semantics"},"Create Semantics"),Object(l.b)("p",null,"If you declare a function like so:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"declare function Getter() create text;\n")),Object(l.b)("p",null,"Then CQL assumes that the function created a new result which it is now responsible for releasing.  In short the returned object is assumed to arrive with a retain count of 1 already on it.  When CQL stores this return value it will:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"release the object that was present at the storage location (if any)"),Object(l.b)("li",{parentName:"ul"},"copy the returned pointer without further retaining it this one time")),Object(l.b)("p",null,"As a result if you store the returned value in a local variable it will be released when the procedure exits (as usual) or if you instead store the result in a global or an out parameter the result will survive to be used later."),Object(l.b)("h3",{id:"comparison"},"Comparison"),Object(l.b)("p",null,"CQL tries to adhere to normal SQL comparison rules but with a C twist."),Object(l.b)("h3",{id:"blob-and-object"},Object(l.b)("inlineCode",{parentName:"h3"},"BLOB")," and ",Object(l.b)("inlineCode",{parentName:"h3"},"OBJECT")),Object(l.b)("p",null,"These types have no value based comparison, so there is no ",Object(l.b)("inlineCode",{parentName:"p"},"<"),", ",Object(l.b)("inlineCode",{parentName:"p"},">")," and so forth."),Object(l.b)("p",null,"The following table is useful.  Let's suppose there are exactly two objects 'X' and 'Y'"),Object(l.b)("p",null,"true expressions: ",Object(l.b)("inlineCode",{parentName:"p"},"X = X"),"   ",Object(l.b)("inlineCode",{parentName:"p"},"X <> Y")," ",Object(l.b)("inlineCode",{parentName:"p"},"Y = Y"),"   ",Object(l.b)("inlineCode",{parentName:"p"},"Y <> X")),Object(l.b)("p",null,"false expressions: ",Object(l.b)("inlineCode",{parentName:"p"},"X = Y"),"  ",Object(l.b)("inlineCode",{parentName:"p"},"X <> X")," ",Object(l.b)("inlineCode",{parentName:"p"},"Y = X"),"  ",Object(l.b)("inlineCode",{parentName:"p"},"Y <> Y")),Object(l.b)("p",null,"null expressions: ",Object(l.b)("inlineCode",{parentName:"p"},"null = null"),"  ",Object(l.b)("inlineCode",{parentName:"p"}," X <> null"),"   ",Object(l.b)("inlineCode",{parentName:"p"},"x = null")," ",Object(l.b)("inlineCode",{parentName:"p"},"null <> null"),"  ",Object(l.b)("inlineCode",{parentName:"p"},"Y <> null"),"   ",Object(l.b)("inlineCode",{parentName:"p"},"y = null")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"null = null")," resulting in ",Object(l.b)("inlineCode",{parentName:"p"},"null")," is particular surprising but consistent with the usual SQL rules.  And again, as in SQL, the ",Object(l.b)("inlineCode",{parentName:"p"},"IS")," operator returns true for ",Object(l.b)("inlineCode",{parentName:"p"},"X IS Y")," even if both are ",Object(l.b)("inlineCode",{parentName:"p"},"null"),"."),Object(l.b)("h3",{id:"text"},Object(l.b)("inlineCode",{parentName:"h3"},"TEXT")),Object(l.b)("p",null,"Text has value comparison semantics but normal string comparison is done only with ",Object(l.b)("inlineCode",{parentName:"p"},"strcmp")," which is of limited value.  Typically you'll want to either delegate the comparison to Sqlite (with ",Object(l.b)("inlineCode",{parentName:"p"},"(select x < y)"),") or else use a helper function with a suitable comparison mechanism."),Object(l.b)("p",null,"For text comparisons including equality:"),Object(l.b)("p",null,"true:   if and only if both operands are not null and the comparison matches (using strcmp)\nfalse:  if and only if  both operands are not null and the comparison does not match (using strcmp)\nnull:   if and only if at least one operand is null"),Object(l.b)("p",null,"EXAMPLE: ",Object(l.b)("inlineCode",{parentName:"p"},"'x' < 'y'"),"  is true because ",Object(l.b)("inlineCode",{parentName:"p"},'strcmp("x", "y") < 0')),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"IS")," and ",Object(l.b)("inlineCode",{parentName:"p"},"IS NOT")," operators behave similarly to equality and inequality, but never return ",Object(l.b)("inlineCode",{parentName:"p"},"null"),".  If ",Object(l.b)("inlineCode",{parentName:"p"},"X")," is some value that doesn't happen to be ",Object(l.b)("inlineCode",{parentName:"p"},"null")," then we have the following:"),Object(l.b)("p",null,"true:  ",Object(l.b)("inlineCode",{parentName:"p"},"null is null")," ",Object(l.b)("inlineCode",{parentName:"p"},"X is X")," ",Object(l.b)("inlineCode",{parentName:"p"},"X is not null")," ",Object(l.b)("inlineCode",{parentName:"p"},"null is not X"),"\nfalse: ",Object(l.b)("inlineCode",{parentName:"p"},"null is not null")," ",Object(l.b)("inlineCode",{parentName:"p"},"X is not X")," ",Object(l.b)("inlineCode",{parentName:"p"},"X is null")," ",Object(l.b)("inlineCode",{parentName:"p"},"null  is X")),Object(l.b)("h3",{id:"sample-code"},"Sample Code"),Object(l.b)("h4",{id:"out-argument-semantics"},"Out Argument Semantics"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"DECLARE FUNCTION foo() OBJECT;\n\nCREATE PROC foo_user (OUT baz OBJECT)\nBEGIN\n  SET baz := foo();\nEND;\n\nvoid foo_user(cql_object_ref _Nullable *_Nonnull baz) {\n  *(void **)baz = NULL; // set out arg to non-garbage\n  cql_set_object_ref(baz, foo());\n}\n")),Object(l.b)("h4",{id:"function-with-create-semantics"},"Function with Create Semantics"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"DECLARE FUNCTION foo() CREATE OBJECT;\n\nCREATE PROCEDURE foo_user (INOUT baz OBJECT)\nBEGIN\n  DECLARE x OBJECT;\n  SET x := foo();\n  SET baz := foo();\nEND;\n\nvoid foo_user(cql_object_ref _Nullable *_Nonnull baz) {\n  cql_object_ref x = NULL;\n\n  cql_object_release(x);\n  x = foo();\n  cql_object_release(*baz);\n  *baz = foo();\n\ncql_cleanup:\n  cql_object_release(x);\n}\n")),Object(l.b)("h4",{id:"function-with-get-semantics"},"Function with Get Semantics"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"DECLARE FUNCTION foo() OBJECT;\n\nCREATE PROCEDURE foo_user (INOUT baz OBJECT)\nBEGIN\n  DECLARE x OBJECT;\n  SET x := foo();\n  SET baz := foo();\nEND;\n\nvoid foo_user(cql_object_ref _Nullable *_Nonnull baz) {\n  cql_object_ref x = NULL;\n\n  cql_set_object_ref(&x, foo());\n  cql_set_object_ref(baz, foo());\n\ncql_cleanup:\n  cql_object_release(x);\n}\n")))}c.isMDXComponent=!0}}]);