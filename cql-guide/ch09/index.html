<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Chapter 9: Statements Summary and Error Checking | CG/SQL</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Chapter 9: Statements Summary and Error Checking | CG/SQL"><meta data-react-helmet="true" name="description" content="&lt;!---"><meta data-react-helmet="true" property="og:description" content="&lt;!---"><meta data-react-helmet="true" property="og:url" content="https://dmitryvinn.github.io/cql-guide/ch09"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://dmitryvinn.github.io/cql-guide/ch09"><link rel="stylesheet" href="/styles.d985c265.css">
<link rel="preload" href="/styles.1bbf445e.js" as="script">
<link rel="preload" href="/runtime~main.c3231b5f.js" as="script">
<link rel="preload" href="/main.85a11c1d.js" as="script">
<link rel="preload" href="/1.5652f5db.js" as="script">
<link rel="preload" href="/2.26ec7d90.js" as="script">
<link rel="preload" href="/3.deb1c333.js" as="script">
<link rel="preload" href="/1be78505.cae5a4c3.js" as="script">
<link rel="preload" href="/46.b422d852.js" as="script">
<link rel="preload" href="/5456faf3.e33591e6.js" as="script">
<link rel="preload" href="/17896441.9e080e0c.js" as="script">
<link rel="preload" href="/b630d056.27fb8d19.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">CQ/SQL</strong></a><a class="navbar__item navbar__link" href="/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/cql-guide/ch01">CQL Guide</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">CQ/SQL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/cql-guide/ch01">CQL Guide</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">CQL Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch01">Chapter 1: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch02">Chapter 2: Using Data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch03">Chapter 3: Expressions, Literals, Nullability, Sensitivity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch04">Chapter 4: Procedures, Functions, and Control Flow</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch05">Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch06">Chapter 6: Calling Procedures Defined Elsewhere</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch07">Chapter 7: CQL Result Sets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch08">Chapter 8: Functions</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/cql-guide/ch09">Chapter 9: Statements Summary and Error Checking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch10">Chapter 10: Schema Management Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch11">Chapter 11: Previous Schema Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch12">Chapter 12: Testability Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch13">Chapter 13: JSON Output</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/cql-guide/ch14">Chapter 14: CQL Query Fragments</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Appendix</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x1">Appendix 1: Command Line Options</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x2">Appendix 2: CQL Grammar</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x3">Appendix 3: Control Directives</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x4">Chapter 4: CQL Error Codes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/cql-guide/x5">Appendix 5: JSON Schema Grammar</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Chapter 9: Statements Summary and Error Checking</h1></header><div class="markdown"><p>The following is a brief discussion of the major statement types and the semantic rules that CQL enforces for each of the statements.  A detailed discussion of SQL statements (the bulk of these) is beyond the scope of this document and you should refer to the SQLite documentation for most details.  However, in many cases CQL does provide additional enforcement and it is helpful to describe the basic checking that happens for each fragment of CQL.  A much
more authoritative list of the things CQL checks for can be inferred from the error documentation.  &quot;Tricky&quot; errors have examples and suggested remediation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primary-sql-statements"></a>The Primary SQL Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primary-sql-statements" title="Direct link to heading">#</a></h3><p>These are roughly, the statements that involve the database.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-select-statement"></a>The <code>SELECT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-select-statement" title="Direct link to heading">#</a></h4><p>Top level statement list processing for select.  This is easily the hardest
statement to process. Each clause has its own set of complex rules and
the result of previous clauses constrains the next in a complex fashion.
Among the things that are verified:</p><ul><li>the mentioned tables exist and have the mentioned columns</li><li>the columns are type compatible in their context</li><li>any variables in the expressions are compatible</li><li>aggregate functions are used only in places where aggregation makes sense</li><li>column and table names are unambiguous, especially when self-joins are involved</li><li>compound selects (e.g. with UNION) are type-consistent in all the fragments</li><li>the projection of a select has unique column labels if they are used</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-select--statement"></a>The <code>SELECT *</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-select--statement" title="Direct link to heading">#</a></h4><p>Select <em> is special in that it creates its own struct type by assembling
all the columns of all the tables in the selects join result.  CQL rewrites these statement into
a select with the specific columns explicitly listed.  While this makes the program
slightly bigger it means that logically deleted columns are never present in results
because `SELECT </em>` won&#x27;t select them and attempting to use a logically deleted
column results in an error.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-create-table-statement"></a>The <code>CREATE TABLE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-create-table-statement" title="Direct link to heading">#</a></h4><p>Unlike the other parts of DDL we actually deeply care about the tables.
We have to grab all the columns and column types out of it and create
the appropriate structure type for the table.
Along the way we validate a bunch of stuff like:</p><ul><li>verify unique table name</li><li>no duplicate column names</li><li>recursive correctness of constraints (see constraints discussion below)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-create-index-statement"></a>The <code>CREATE INDEX</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-create-index-statement" title="Direct link to heading">#</a></h4><p>CQL doesn&#x27;t really do anything with indices but we do validate that they make sense (so we lookup all the names of all the columns and so forth).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-create-view-statement"></a>The <code>CREATE VIEW</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-create-view-statement" title="Direct link to heading">#</a></h4><p>Create view analysis is very simple because the <code>select</code> analysis does the heavy lifting.  All we
have to do is validate that the view is unique, then validate the select statement.</p><p>Additionally, views must not be allowed to have any NULL type columns, all nulls must be converted to
some type with a CAST.   e.g. <code>create view foo as select NULL n</code> is not valid.  NULL is not a real storage type.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-create-trigger-statement"></a>The <code>CREATE TRIGGER</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-create-trigger-statement" title="Direct link to heading">#</a></h4><p>The create trigger statement is quite a beast, validations include:</p><ul><li>the trigger name must be unique</li><li>For <code>insert</code> the &quot;new.*&quot; table is available in expressions/statement</li><li>For <code>delete</code> the &quot;old.*&quot; table is available in expressions/statements</li><li>For <code>update</code> both are available<ul><li>If optional columns present in the <code>update</code>, they must be unique/valid</li></ul></li><li>The <code>when</code> expression must evaluate to a numeric</li><li>The statement list must be error free with the usual rules plus new/old</li><li>The <code>raise</code> function may be used inside a trigger (NYI)</li><li>The table name must be a table (not a view) UNLESS the trigger type is <code>INSTEAD OF</code></li><li>select statements inside the statement block do not count as returns for the procedure that includes the create trigger</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-drop-table-statement"></a>The <code>DROP TABLE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-drop-table-statement" title="Direct link to heading">#</a></h4><p>This is the basic checking for the drop table statement:</p><ul><li>the table must exist in some version</li><li>it has to be a table and not a view</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-drop-view-statement"></a>The <code>DROP VIEW</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-drop-view-statement" title="Direct link to heading">#</a></h4><p>This is the basic checking for the drop view statement:</p><ul><li>the view must exist in some version</li><li>it has to be a view and not a table</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-drop-index-statement"></a>The <code>DROP INDEX</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-drop-index-statement" title="Direct link to heading">#</a></h4><p>This is the basic checking for the drop index statement:</p><ul><li>the index must exist in some version</li><li>it could be deleted now, that&#x27;s ok, but the name has to be valid</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-drop-trigger-statement"></a>The <code>DROP TRIGGER</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-drop-trigger-statement" title="Direct link to heading">#</a></h4><p>This is the basic checking for the drop trigger statement</p><ul><li>the trigger  must exist in some version</li><li>it could be deleted now, that&#x27;s ok, but the name has to be valid</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-unique-key-clause"></a>The <code>UNIQUE KEY</code> Clause<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-unique-key-clause" title="Direct link to heading">#</a></h4><p>Similar to other constraints, we don&#x27;t actually do anything with this
other than offer some validation.  Again we use the usual helpers
for name lookup within the context of the table that contains the constraint.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-foreign-key-clause"></a>The <code>FOREIGN KEY</code> Clause<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-foreign-key-clause" title="Direct link to heading">#</a></h4><p>Similar to other constraints, we don&#x27;t actually do anything with this
other than offer some validation.  Again we use the usual helpers
for name lookup within the context of the table with the foreign key.
Note that the foreign has to be validated against two tables to fully validate it.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primary-key-clause"></a>The <code>PRIMARY KEY</code> Clause<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primary-key-clause" title="Direct link to heading">#</a></h4><p>Similar to other constraints, we don&#x27;t actually do anything with this
other than offer some validation.  Again we use the usual helpers
for name lookup within the context of the table with the primary key.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-raise-statement"></a>The <code>RAISE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-raise-statement" title="Direct link to heading">#</a></h4><p>CQL validates that <code>RAISE</code> is being used in the context of a trigger and that
it has the correct arguments.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-alter-table-add-column-statement"></a>The <code>ALTER TABLE ADD COLUMN</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-alter-table-add-column-statement" title="Direct link to heading">#</a></h4><p>To validate <code>alter table add column</code> we check the following:</p><ul><li>the table must exist and not be a view (in any version)</li><li>the column definition of the new column must be self-consistent</li><li>no auto increment columns may be added</li><li>added columns must be either nullable or have a default value</li></ul><p>Note: Alter statements are typically used in the context of migration so it&#x27;s
possible the table that is mentioned is condemned in a future version.  We still have to run
the intervening upgrade steps so basically DDL gets to ignore the current deadness
of the table as in context it&#x27;s might be &quot;not dead yet&quot;.  This will be more obvious
in the context of the schema maintenance features. (q.v.)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-delete-statement"></a>The <code>DELETE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-delete-statement" title="Direct link to heading">#</a></h4><p>The delete analyzer sets up a scope for the table being
deleted and the validates the WHERE clause if present against that scope.
Additionally we verify that the table actually was defined and is not a view.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-update-statement"></a>The <code>UPDATE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-update-statement" title="Direct link to heading">#</a></h4><p>The update analyzer sets up the scope for the table(s) being updated.  If there are
optional clauses (e.g. <code>LIMIT</code>) they are evaluated just like in a select statement
with those same helper methods.  Expression fragments are evaluated just as
in a select statement.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-insert-statement"></a>The <code>INSERT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-insert-statement" title="Direct link to heading">#</a></h4><p>We check that the table exists and then we walk the columns and the value list
to make sure they are valid for the table. Also we cannot insert into a view.</p><p>Details:</p><ul><li>The column list specifies the columns we will provide, they must exist and be unique.</li><li>The columns specified must suffice to insert a row (all not nulls and not default present)</li><li>The insert list specifies the values that are to be inserted.</li><li>The type of each value must match the type of the column.</li><li>Autoinc columns may be specified as NULL.</li><li>If there are too many or too few columns, that is an error.</li><li>If no columns are specified that is the same as if all columns had been specified, in table order</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-throw-statement"></a>The <code>THROW</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-throw-statement" title="Direct link to heading">#</a></h4><p>Throw can literally go anywhere, so it&#x27;s always ok.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-begin-transaction-statement"></a>The <code>BEGIN TRANSACTION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-begin-transaction-statement" title="Direct link to heading">#</a></h4><p>Begin transaction can go anywhere, it&#x27;s always ok.</p><p>The sqlite documentation can be helpful (CQL syntax is a subset).  See: <a href="https://www.sqlite.org/lang_transaction.html" target="_blank" rel="noopener noreferrer">https://www.sqlite.org/lang_transaction.html</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-commit-transaction-statement"></a>The <code>COMMIT TRANSACTION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-commit-transaction-statement" title="Direct link to heading">#</a></h4><p>Commit transaction can go anywhere, it&#x27;s always ok.</p><p>The sqlite documentation can be helpful (CQL syntax is a subset).  See: <a href="https://www.sqlite.org/lang_transaction.html" target="_blank" rel="noopener noreferrer">https://www.sqlite.org/lang_transaction.html</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-rollback-transaction-statement"></a>The <code>ROLLBACK TRANSACTION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-rollback-transaction-statement" title="Direct link to heading">#</a></h4><p>Rollback trans can go anywhere but if you&#x27;re using the format
where you rollback to a particular save point then we must have
seen that name in a <code>savepoint</code> statement previously or it&#x27;s an error.</p><p>The sqlite documentation can be helpful (CQL syntax is a subset).  See: <a href="https://www.sqlite.org/lang_transaction.html" target="_blank" rel="noopener noreferrer">https://www.sqlite.org/lang_transaction.html</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-savepoint-statement"></a>The <code>SAVEPOINT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-savepoint-statement" title="Direct link to heading">#</a></h4><p>The <code>savepoint</code> statement can go anywhere but we do record this savepoint name
as having been seen so we can verify it in rollback.  So this is sort of a weak declaration of the savepoint name.</p><p>The sqlite documentation can be helpful (CQL syntax is a subset).  <a href="https://www.sqlite.org/lang_savepoint.html" target="_blank" rel="noopener noreferrer">https://www.sqlite.org/lang_savepoint.html</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-release-savepoint-statement"></a>The <code>RELEASE SAVEPOINT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-release-savepoint-statement" title="Direct link to heading">#</a></h4><p>Release savepoint can go anywhere but we must have
seen that name in a previous <code>savepoint</code> statement or it&#x27;s an error.</p><p>The sqlite documentation can be helpful (CQL syntax is a subset). <a href="https://www.sqlite.org/lang_savepoint.html" target="_blank" rel="noopener noreferrer">https://www.sqlite.org/lang_savepoint.html</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-primary-procedure-statements"></a>The Primary Procedure Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-primary-procedure-statements" title="Direct link to heading">#</a></h3><p>These are the statements which form the language of procedures, and do not involve the database.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-create-procedure-statement"></a>The <code>CREATE PROCEDURE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-create-procedure-statement" title="Direct link to heading">#</a></h4><p>Semantic analysis of stored procedures is fairly easy at the core:</p><ul><li>check for duplicate names</li><li>validate the parameters are well formed</li><li>set the current proc in flight (this not allowed to nest)</li><li>recurse on the statement list and prop errors</li><li>record the name of the procedure for callers
In addition, while processing the statement:</li><li>we determine if it uses the database, this will change the emitted signature of the proc to include a <code>sqlite3 *db</code>
input argument and it will return a sqlite error code (e.g. <code>SQLITE_OK</code>)</li><li>select statements that are loose in the proc represent the &quot;return&quot; of that
select;  this changes the signature to include a <code>sqlite3_stmt **pstmt</code> parameter corresponding to the returned statement</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-if-statement"></a>The <code>IF</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-if-statement" title="Direct link to heading">#</a></h4><p>The top level if node links the initial condition with a possible
series of else_if nodes and then the else node.  Each condition is
checked for validity. The conditions must be valid expressions that
can be converted to a boolean.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-set-statement"></a>The <code>SET</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-set-statement" title="Direct link to heading">#</a></h4><p>The set statement is for variable assignment.  We just validate
that the target exists and is compatible with the source.
Cursor variables cannot be set with simple assignment and CQL generates
errors if you attempt to do so.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare-procedure-statement"></a>The <code>DECLARE PROCEDURE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare-procedure-statement" title="Direct link to heading">#</a></h4><p>There are three forms of this declaration:</p><ul><li>a regular procedure with no DML<ul><li>e.g. <code>declare proc X(id integer);</code></li></ul></li><li>a regular procedure that uses DML (it will need a db parameter and returns a result code)<ul><li>e.g. <code>declare proc X(id integer) using transaction;</code></li></ul></li><li>a procedure that returns a result set, you provide the result columns<ul><li>e.g. <code>declare proc X(id integer) : (A bool not null, B text);</code>
The main validations here are that there are no duplicate parameter names, or return value columns.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare-function-statement"></a>The <code>DECLARE FUNCTION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare-function-statement" title="Direct link to heading">#</a></h4><p>Function declarations are similar to than procedures; there must be a return type
(use proc if there is none).  The <code>DECLARE SELECT FUNCTION</code> form indicates a function
visible to SQLite, other functions are usable in the <code>call</code> statement.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare-variable-statement"></a>The <code>DECLARE</code> Variable Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare-variable-statement" title="Direct link to heading">#</a></h4><p>This declares a new local or global variable that is not a cursor.
The type is computed with the same helper that is used for analyzing
column definitions.  Once we have the type we walk the list of variable
names, check them for duplicates and such (see above) and assign their type.  The canonical
name of the variable is defined here, if it is later used with a different casing the output
will always be as declared.   e.g. <code>declare Foo integer;  set foo = 1;</code> is legal but the output
will always contain the variable written as <code>Foo</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare-cursor-statement"></a>The <code>DECLARE</code> Cursor Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare-cursor-statement" title="Direct link to heading">#</a></h4><p>There are two forms of the declare cursor, both of which allow CQL to infer the exact type of the cursor.</p><ul><li><code>declare foo cursor for select etc.</code><ul><li>the type of the cursor is the net struct type of the select list</li></ul></li><li><code>declare foo cursor for call proc();</code><ul><li>proc must be statement that produces a result set via select (see above)</li><li>the type of the cursor is the struct of the select returned by the proc</li><li>note if there is more than one loose select in the proc they must match exactly</li></ul></li><li>cursor names have the same rules duplicates as other variables
With this in mind, both cases simply recurse on either the select or the call
and then pull out the structure type of that thing and use it for the cursor&#x27;s shape.  If the
<code>call</code> is not semantically valid according to the rules for calls or the <code>select</code> is not semantically valid,
then of course this declaration will generate errors.</li></ul><p>[marker: initial proof reading ended here, what follows is much rougher]</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare-value-cursor-statement"></a>The <code>DECLARE</code> Value Cursor Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare-value-cursor-statement" title="Direct link to heading">#</a></h4><p>This statement declares a cursor that will be based on the return type of a procedure
when using this form the cursor is also fetched, hence the name.  The fetch result of
the stored proc will be used for the value.  At this point we use its type only.</p><ul><li>the call must be semantically valid</li><li>the procedure must return an OUT parameter (not a result set)</li><li>the cursor name must be unique</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-while-statement"></a>The <code>WHILE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-while-statement" title="Direct link to heading">#</a></h4><p>While semantic analysis is super simple.</p><ul><li>the condition must be numeric</li><li>the statement list must be error-free</li><li>loop_depth is increased allowing the use of interior leave/continue</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-loop-statement"></a>The <code>LOOP</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-loop-statement" title="Direct link to heading">#</a></h4><p>Loop analysis is just as simple as &quot;while&quot; -- because the loop_stmt
literally has an embedded fetch, you simply use the fetch helper to
validate that the fetch is good and then visit the statement list.
Loop depth is increased as with while.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-call-statement"></a>The <code>CALL</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-call-statement" title="Direct link to heading">#</a></h4><p>There are three ways that a call can happen:</p><ul><li>signatures of procedures that we know in full:<ul><li>call foo();</li><li>declare cursor for call foo();</li></ul></li><li>some external call to some outside function we don&#x27;t known<ul><li>e.g. call printf(&#x27;hello, world\n&#x27;);</li></ul></li></ul><p>The cursor form can be used if and only if the procedure has a loose select
or a call to a procedure with a loose select. In that case the procedure will
have a structure type, rather than just &quot;ok&quot; (the normal signature for a proc).
If the user is attempting to do the second case, cursor_name will be set and
the appropriate verification happens here.</p><p>Note:  Recursively calling fetch cursor is not really doable in general
because at the point of the call we might not yet know that the method
does in fact return a select.  You could make it work if you put the select
before the recursive call.</p><p>Semantic rules:</p><ul><li>for all cases each argument must be error-free (no internal type conflicts)</li><li>for known procs<ul><li>the call has to have the correct number of arguments</li><li>if the formal is an out parameter the argument must be a variable<ul><li>the type of the variable must be an exact type match for the formal</li></ul></li><li>non-out parameters must be type-compatable, but exact match is not required</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-fetch-statement"></a>The <code>FETCH</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-fetch-statement" title="Direct link to heading">#</a></h4><p>The fetch statement has two forms:</p><ul><li>fetch C into var1, var2, var3 etc.</li><li>fetch C;
The second form is called the auto_cursor.
In the first form the variables of the cursor must be assignment compatable
with declared structure type of the cursor and the count must be correct.
In the second form, the codegen will implicitly create local variables that
are exactly the correct type, but that&#x27;s later.  Since no semantic error is
possible in that case we simply record that this is an auto_cursor and then
later we will allow the use of C.field during analysis.
Of course &quot;C&quot; must be a valid cursor.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-continue-statement"></a>The <code>CONTINUE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-continue-statement" title="Direct link to heading">#</a></h4><p>We just need to ensure that continue is inside a loop.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-leave-statement"></a>The <code>LEAVE</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-leave-statement" title="Direct link to heading">#</a></h4><p>We just need to ensure that leave is inside a loop.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-trycatch-statements"></a>The <code>TRY/CATCH</code> Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-trycatch-statements" title="Direct link to heading">#</a></h4><p>No analysis needed here other than that the two statement lists are ok.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-open-cursor-statement"></a>The <code>OPEN</code> CURSOR Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-open-cursor-statement" title="Direct link to heading">#</a></h4><p>For open [cursor], we just validate that the name is in fact a cursor.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-close-cursor-statement"></a>The <code>CLOSE</code> CURSOR Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-close-cursor-statement" title="Direct link to heading">#</a></h4><p>For close [cursor], we just validate that the name is in fact a cursor.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-out-cursor-statement"></a>The <code>OUT</code> CURSOR Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-out-cursor-statement" title="Direct link to heading">#</a></h4><p>For out [cursor], we first validate that the name is a cursor
then we set the output type of the procedure we&#x27;re in accordingly</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-meta-statements"></a>The &quot;Meta&quot; Statements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-meta-statements" title="Direct link to heading">#</a></h3><p>The programs control the overall meaning the program or give the compiler specific directives
as to how the program should be compiled.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-echo-statement"></a>The <code>@ECHO</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-echo-statement" title="Direct link to heading">#</a></h4><p>echo is valid in any top level contexts</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-previous-schema-statement"></a>The <code>@PREVIOUS SCHEMA</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-previous-schema-statement" title="Direct link to heading">#</a></h4><p>Begins the region where previous schema will be compared against what has been
declared before this directive for alterations that could not be upgraded.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-schema_upgrade_script-statement"></a>The <code>@SCHEMA_UPGRADE_SCRIPT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-schema_upgrade_script-statement" title="Direct link to heading">#</a></h4><p>When upgrading the DDL it&#x27;s necessary to emit create table statements
for the original version of the schema.  These create statements conflict
with the current version of the schema.  This attribute tells CQL to
1) ignore DDL in stored procedures for declaration purposes; only DDL outside of a proc counts
2) do not make any columns &quot;hidden&quot; thereby allowing all annotations to be present
so they can be used to validate other aspects of the migration script.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-schema_upgrade_version-statement"></a>The <code>@SCHEMA_UPGRADE_VERSION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-schema_upgrade_version-statement" title="Direct link to heading">#</a></h4><p>For sql stored procedures that are supposed to update previous schema versions
you can use this attribute to put CQL into that mindset.  This will make
the columns hidden for the version in question rather than the current version.
This is important because older schema migration procedures might still refer to
old columns.  Those columns truly exist at that schema version.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-enforce_strict-statement"></a>The <code>@ENFORCE_STRICT</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-enforce_strict-statement" title="Direct link to heading">#</a></h4><p>Switch to strict mode.  Presently this is only supported for <code>FOREIGN KEY</code> verification.  In strict mode every foreign key must have some delete/update policy such as <code>ON DELETE CASCADE</code>.  Any policy suffices.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-enforce_normal-statement"></a>The <code>@ENFORCE_NORMAL</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-enforce_normal-statement" title="Direct link to heading">#</a></h4><p>Turn off strict enforcement (currently only affects <code>FOREIGN KEY</code> clauses).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-declare_schema_region-statement"></a>The <code>@DECLARE_SCHEMA_REGION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-declare_schema_region-statement" title="Direct link to heading">#</a></h4><p>A schema region is an partitioning of the schema such that it
only uses objects in the same partition or one of its declared
dependencies.  One schema region may be upgraded independently
from any others (assuming they happen such that dependents are done first).
Here we validate:</p><ul><li>the region name is unique</li><li>the dependencies (if any) are unique and exist</li><li>the directive is not inside a procedure</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-begin_schema_region-statement"></a>The <code>@BEGIN_SCHEMA_REGION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-begin_schema_region-statement" title="Direct link to heading">#</a></h4><p>Entering a schema region makes all the objects that follow part of that
region.  It also means that all the contained objects must refer to
only pieces of schema that are in the same region or a dependent region.
Here we validate that region we are entering is in fact a valid region
and that there isn&#x27;t already a schema region.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-end_schema_region-statement"></a>The <code>@END_SCHEMA_REGION</code> Statement<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-end_schema_region-statement" title="Direct link to heading">#</a></h4><p>Leaving a schema region puts you back in the default region.
Here we check that we are in a schema region.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="important-program-fragments"></a>Important Program Fragments<a aria-hidden="true" tabindex="-1" class="hash-link" href="#important-program-fragments" title="Direct link to heading">#</a></h3><p>These items appear in a variety of places and are worth of discussion.  They are generally handled uniformly.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="argument-lists"></a>Argument Lists<a aria-hidden="true" tabindex="-1" class="hash-link" href="#argument-lists" title="Direct link to heading">#</a></h4><p>Walk an entire argument list and do the type inference on each argument.
Not that this happens in the context of a function call and depending
on what the function is, there may be rules for compatibility of the
arguments with the function and each other.  That doesn&#x27;t happen here.
This just gets the type of each arg and makes sure independently they are
not bogus.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="procedures-that-return-a-result-set"></a>Procedures that return a Result Set<a aria-hidden="true" tabindex="-1" class="hash-link" href="#procedures-that-return-a-result-set" title="Direct link to heading">#</a></h4><p>If a procedure is returning a select statement then we need to attach that
type to the procedures semantic info.  We have to do some extra validation
at this point, especially if the proc already has some other select return.
This is where we make sure all the kinds of selects that might be returned
are 100% compatible.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="general-name-lookups"></a>General Name Lookups<a aria-hidden="true" tabindex="-1" class="hash-link" href="#general-name-lookups" title="Direct link to heading">#</a></h4><p>Try to look up a [possibly] scoped name in one of the places:</p><ol><li>a column in the current join if any (this must not conflict with #2)</li><li>a local or global variable</li><li>a field in an open cursor
otherwise, name not found.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="object-types-with-a-discriminator"></a>Object Types with a Discriminator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#object-types-with-a-discriminator" title="Direct link to heading">#</a></h4><p>We check that <code>object&lt;Foo&gt;</code> only combines with <code>object&lt;Foo&gt;</code> or <code>object</code> in lists of objects (like IN)</p><ul><li>If there is a current object type, then the next item in the expression or must match</li><li>If there is no such type, then an object type that arrives becomes the required type</li><li>If they ever don&#x27;t match record an error</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-case-expression"></a>The <code>CASE</code> Expression<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-case-expression" title="Direct link to heading">#</a></h4><p>There are two parts to this, the &quot;when&quot; expression and the &quot;then&quot; expression.
We compute the aggregate type of the when expressions as we go, promoting it
up to a larger type if needed (e.g. if one when is an int and the other is
a real then the result is a real).   Likewise nullability is computed as
the aggregate.  Note that if nothing matches the result is null, so we always
get a nullable result unless there is an &quot;else&quot; expression.
If we started with case expr then each when expression must be comparable
to the case expression.  If we started with case when xx then yy;  then
each case expression must be numeric (typically boolean).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-between-expressions"></a>The <code>BETWEEN</code> EXPRESSIONS<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-between-expressions" title="Direct link to heading">#</a></h4><p>Between requires type compatibility between all three of its arguments.
Nullability follows the usual rules, if any might be null then the result
type might be null.  In any case the result&#x27;s core type is BOOL.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-cast-expression"></a>The <code>CAST</code> Expression<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-cast-expression" title="Direct link to heading">#</a></h4><p>For cast expressions we use the type provided for the semantic type
the only trick is that we preserve the combined_flags of the input argument.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-coalesce-function"></a>The <code>COALESCE</code> Function<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-coalesce-function" title="Direct link to heading">#</a></h4><p>Coalesce requires type compatibility between all of its arguments.  The result
is a not null type if we find a not null item in the list.  There should be
nothing after that item.  Note that ifnull and coalesce are really the same thing
except ifnull must have exactly two arguments.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-in-and-not-in-expressions"></a>The <code>IN</code> AND <code>NOT IN</code> Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-in-and-not-in-expressions" title="Direct link to heading">#</a></h4><p>The in predicate is like many of the other multi-argument operators.  All the
items must be type compatible.  Note that in this case the nullablity of
the items does not matter, only the nullability of the item being tested.
Note that null in (null) is null, not true.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="aggregate-functions"></a>Aggregate Functions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#aggregate-functions" title="Direct link to heading">#</a></h4><p>Aggregate functions can only be used in certain places.  For instance
they may not appear in a <code>WHERE</code> clause.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="user-defined-functions"></a>User Defined Functions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#user-defined-functions" title="Direct link to heading">#</a></h4><p>User defined function, this is an external function
There are a few things to check:</p><ul><li>If this is declared without the select keyword then<ul><li>we can&#x27;t use these in SQL, so this has to be a loose expression</li></ul></li><li>If this is declared with the select keyword then<ul><li>we can ONLY use these in SQL, not in a loose expression</li></ul></li><li>args have to be compatible with formals</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="calling-a-procedure-as-a-function"></a>Calling a procedure as a function<a aria-hidden="true" tabindex="-1" class="hash-link" href="#calling-a-procedure-as-a-function" title="Direct link to heading">#</a></h4><p>There are a few things to check:</p><ul><li>we can&#x27;t use these in SQL, so this has to be a loose expression</li><li>args have to be compatible with formals, except</li><li>the last formal must be an OUT arg and it must be a scalar type</li><li>that out arg will be treated as the return value of the &quot;function&quot;</li><li>in code-gen we will create a temporary for it, semantic analysis doesn&#x27;t care</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="root-expressions"></a>Root Expressions<a aria-hidden="true" tabindex="-1" class="hash-link" href="#root-expressions" title="Direct link to heading">#</a></h4><p>A top level expression defines the context for that evaluation.  Different expressions
can have constraints.  e.g. aggregate functions may not appear in the <code>WHERE</code> clause of a statement.  There are cases where expression nesting can happen, this nesting changes the evaluation context accordingly, e.g. you can put a nested select in a where clause and that
nested select could legally have aggregates.  Root expressions keep a stack of nested contexts to facilitate the changes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="table-factors"></a>Table Factors<a aria-hidden="true" tabindex="-1" class="hash-link" href="#table-factors" title="Direct link to heading">#</a></h4><p>A table factor is one of three things:</p><ul><li>a table name (a string)  select * from X</li><li>a select subquery (select X,Y from..) as T2</li><li>a list of table references select * from (X, Y, Z)
Here we dispatch to the appropriate helper for each case.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="joining-with-the-using-clause"></a>Joining with the <code>USING</code> Clause<a aria-hidden="true" tabindex="-1" class="hash-link" href="#joining-with-the-using-clause" title="Direct link to heading">#</a></h4><p>When specifying joins, one of the alternatives is to give the shared
columns in the join e.g. select * from X inner join Y using (a,b).
This method validates that all the columns are present on both sides of the
join, that they are unique, and they are comparable.
The return code tells us if any columns had SENSITIVE data.   See Special Note on JOIN...USING below</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="join-with-the-on-clause"></a>JOIN WITH THE <code>ON</code> Clause<a aria-hidden="true" tabindex="-1" class="hash-link" href="#join-with-the-on-clause" title="Direct link to heading">#</a></h4><p>The most explicit join condition is a full expression in an ON clause
this is like <code>select a,b from X inner join Y on X.id = Y.id;</code>
The on expression should be something that can be used as a bool
so any numeric will do.
The return code tells us if the ON condition used SENSITIVE data.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="table-valued-functions"></a>TABLE VALUED FUNCTIONS<a aria-hidden="true" tabindex="-1" class="hash-link" href="#table-valued-functions" title="Direct link to heading">#</a></h4><p>Table valued functions can appear anywhere a table is allowed.
The validation rules are:</p><ul><li><p>must be a valid function</p></li><li><p>must return a struct type (i.e. a table-valued-function)</p></li><li><p>must have valid arg expressions</p></li><li><p>arg expressions must match formal parameters
The name of the resulting table is the name of the function</p></li><li><p>but it can be aliased later with &quot;AS&quot;</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="special-note-on-the-select--and-select-t-forms"></a>Special Note on the <code>select *</code> and <code>select T.*</code> forms<a aria-hidden="true" tabindex="-1" class="hash-link" href="#special-note-on-the-select--and-select-t-forms" title="Direct link to heading">#</a></h3><p>The <code>select *</code> construct is very popular in many codebases but it can be unsafe to use in production code because, if the schema changes, the code might get columns it does not expect.  Note the extra columns could have appeared anywhere in the result set because the <code>*</code> applies to the entire result of the <code>FROM</code> clause, joins and all,  so extra columns are not necessarily at the end and column ordinals are not preserved.  CQL mitigates this situation somewhat with some useful constraints/features:</p></li><li><p>in a <code>select *</code>, and indeed in any query, the column names of the select must be unique, this is because:</p><ul><li>they could form the field names of an automatically generated cursor (see the section on cursors)</li><li>they could form the field names in a CQL result set (see section on result sets)</li><li>it&#x27;s weird/confusing to not have unique names generally</li></ul></li><li><p>when issuing a <code>select *</code> or a <code>select T.*</code> CQL will automatically expand the <code>*</code> into the actual logical columns that exist in the schema at the time the code was compiled</p><ul><li>this is important because if a column had been logically deleted from a table it would be unexpected in the result set even though it is still present in the database and would throw everything off</li><li>likewise if the schema were to change without updating the code, the code will still get the columns it was compiled with, not new columns</li></ul></li></ul><p>Expanding the <code>*</code> at compile time means Sqlite cannot see anything that might tempt it to include different columns in the result.</p><p>With this done we just have to look at the places a <code>select *</code> might appear so we can see if it is safe to use <code>*</code> and, by extension of the same argument, <code>T.*</code>, or at least reasonably safe.</p><p><em>In an <code>EXISTS</code> or <code>NOT EXISTS</code> clause like `where not exists (select </em> from x)`*</p><ul><li>this is perfectly safe, the particular columns do not matter, <code>select *</code> is not even expanded in this case.</li></ul><p><em>In a statement that produces a result set like `select </em> from table_or_view`*</p><ul><li>binding to a CQL result set is done by column name and we know those names are unique</li><li>we won&#x27;t include any columns that are logically deleted, so if you try to use a deleted column you&#x27;ll get a compile time error</li></ul><p>In a cursor statement like <code>declare C cursor for select * from table_or_view</code> there are two cases here</p><p><em>Automatic Fetch  <code>fetch C;</code></em></p><ul><li>in this case you don&#x27;t specify the column names yourself, they are inferred</li><li>you are therefore binding to the columns by name, so new columns in the cursor would be unused (until you choose to start using them)</li><li>if you try to access a deleted column you get a compile-time error</li></ul><p><em>Manual Fetch:  <code>fetch C into a, b, c;</code></em></p><ul><li>In this case the number and type of the columns must match exactly with the specified variables</li><li>If new columns are added, deleted, or changed, the above code will not compile</li></ul><p>So consdering these cases above we can conclude that auto expanding the <code>*</code> into the exact columns present in the compile-time schema version ensures that any incompatible changes result in compile time errors. Adding columns to tables does not cause problems even if the code is not recompiled. This makes the <code>*</code> construct much safer, if not perfect, but no semantic would be safe from arbitary schema changes without recompilation.  At the very least here we can expect a meaningful runtime error rather than silently fetching the wrong columns.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="special-note-on-the-joinusing-form"></a>Special Note on the JOIN...USING form<a aria-hidden="true" tabindex="-1" class="hash-link" href="#special-note-on-the-joinusing-form" title="Direct link to heading">#</a></h3><p>CQL varies slightly from SQLite in terms of the expected results for joins if the USING syntax is employed.  This is not the most common syntax (typically an ON clause is used) but Sqlite has special rules for this kind of join.</p><p>Let&#x27;s take a quick look.  First some sample data:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">create table A( id integer, a text, b text);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">create table B( id integer, c text, d text);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">insert into A values(1, &#x27;a1&#x27;, &#x27;b1&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">insert into B values(1, &#x27;c1&#x27;, &#x27;d1&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">insert into A values(2, &#x27;a2&#x27;, &#x27;b2&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">insert into B values(2, &#x27;c2&#x27;, &#x27;d2&#x27;);</span></div></div></div></div></div><p>Now let&#x27;s look at the normal join, this is our reference:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * from A T1 inner join B T2 on T1.id = T2.id;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">result:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">1|a1|b1|1|c1|d1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2|a2|b2|2|c2|d2</span></div></div></div></div></div><p>As expected, you get all the columns of A, and all the columns of B.  The &#x27;id&#x27; column appears twice.</p><p>However with the <code>USING</code> syntax:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select * T1 inner join B T2 using (id);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">result:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">1|a1|b1|c1|d1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2|a2|b2|c2|d2</span></div></div></div></div></div><p>The <code>id</code> column is now appearing exactly once.  However, the situation is not so simple as that.  It seems that what hapened was that the <code>*</code> expansion has not included two copies of the <code>id</code>.  The following cases show that both copies of <code>id</code> are still logically in the join.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select T1.*, &#x27;xxx&#x27;, T2.* from A T1 inner join B T2 using (id);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">result:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">1|a1|b1|xxx|1|c1|d1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2|a2|b2|xxx|2|c2|d2</span></div></div></div></div></div><p>The <code>T2.id</code> column is part of the join, it just wasn&#x27;t part of the <code>*</code></p><p>In fact, looking further:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">select T1.id, T1.a, T1.b, &#x27;xxx&#x27;, T2.id, T2.c, T2.d from A T1 inner join B T2 using (id);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">result:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">1|a1|b1|xxx|1|c1|d1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2|a2|b2|xxx|2|c2|d2</span></div></div></div></div></div><p>There is no doubt, <code>T2.id</code> is a valid column and can be used in expressions freely. That means the column cannot be removed from the type calculus.</p><p>Now in CQL, the <code>*</code> and <code>T.*</code> forms are automatically expanded, SQLite doesn&#x27;t see the <code>*</code>.  This is done so that if any columns have been logically deleted they can be elided from the result set.  Given that this happens, the <code>*</code> operator will expand to ALL the columns.  Just the same as if you did <code>T1.*</code> and <code>T2.*</code>.</p><p><em>As a result, in CQL, there is no difference between  the <code>USING</code> form of a join and the <code>ON</code> form of a join.</em></p><p>In fact, only the <code>select *</code> form could possibly be different, so in most cases this ends up being moot anyway.  Typically you don&#x27;t to use <code>*</code> in the presence of joins because of name duplication and ambiguity of the column names of the result set.  CQL&#x27;s automatic expansion means you have a much better idea exactly what columns you will get -- those that were present in the schema you declared.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2020-10-23T20:06:53.000Z" class="docLastUpdatedAt_217_">10/23/2020</time> by <strong>Dmitry Vinnik</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cql-guide/ch08"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Chapter 8: Functions</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cql-guide/ch10"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Chapter 10: Schema Management Features Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-primary-sql-statements" class="table-of-contents__link">The Primary SQL Statements</a></li><li><a href="#the-primary-procedure-statements" class="table-of-contents__link">The Primary Procedure Statements</a></li><li><a href="#the-meta-statements" class="table-of-contents__link">The &quot;Meta&quot; Statements</a></li><li><a href="#important-program-fragments" class="table-of-contents__link">Important Program Fragments</a></li><li><a href="#special-note-on-the-joinusing-form" class="table-of-contents__link">Special Note on the JOIN...USING form</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Learn</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Getting Started</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/fbOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebookincubator/CG-SQL" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Legal</h4><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy</a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Facebook Open Source Logo" src="/img/oss_logo.png"></a></div><div>Copyright Â© 2020 Facebook, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.1bbf445e.js"></script>
<script src="/runtime~main.c3231b5f.js"></script>
<script src="/main.85a11c1d.js"></script>
<script src="/1.5652f5db.js"></script>
<script src="/2.26ec7d90.js"></script>
<script src="/3.deb1c333.js"></script>
<script src="/1be78505.cae5a4c3.js"></script>
<script src="/46.b422d852.js"></script>
<script src="/5456faf3.e33591e6.js"></script>
<script src="/17896441.9e080e0c.js"></script>
<script src="/b630d056.27fb8d19.js"></script>
</body>
</html>